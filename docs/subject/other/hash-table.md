# 散列表

## 线性探测法

| Key    | 7   | 8   | 30  | 11  | 18  | 9   | 14  |
| ------ | --- | --- | --- | --- | --- | --- | --- |
| H(Key) | 0   | 3   | 6   | 5   | 5   | 6   | 0   |

关键字 7 和 14，30 和 9， 11 和 18，这三组关键子的 H(Key)值相同，这在构建散列表时就会产生冲突

**步骤：**

1. 第一个 key 7，它的地址是 0，因此放到散列表的数组下表为 0 的位置，这个位置上没有关键字，因此没有冲突可以直接填入；
2. 第二个 key 8，它的地址是 3，因此放到散列表的数组下表为 3 的位置，这个位置上没有关键字，因此没有冲突可以直接填入；

3. 第三个 key 30，它的地址是 6，因此放到散列表的数组下表为 6 的位置，这个位置上没有关键字，因此没有冲突可以直接填入；
4. 第四个 key 11，它的地址是 5，因此放到散列表的数组下表为 5 的位置，这个位置上没有关键字，因此没有冲突可以直接填入；

5. 第五个 key 18，它的地址是 5，因此放到散列表的数组下表为 5 的位置，但这个位置上已经有关键字 11，遇到了冲突，此时我们根据线性探测再散列法来处理这个冲突，探测下一个位置 6, 6 这个位置上已经存在关键字 30 则继续增加步长 1，因此现在的新地址应为 7，位置 7 上没有关键字，放入即可，到此冲突已经解决；
6. 第六个 key 9，它的地址是 6，因此放到散列表的数组下表为 6 的位置，但这个位置上已经有关键字 30，遇到了冲突，探测下一个位置 7, 7 这个位置上已经存在关键字 18 则继续增加步长 1，因此现在的新地址应为 8，位置 8 上没有关键字，放入即可；

7. 第七个 key 14，它的地址是 0，因此放到散列表的数组下表为 0 的位置，但这个位置上已经有关键字 7，遇到了冲突，探测下一个位置 1, 位置 1 上没有关键字，放入即可；

**结果：**

| 地址   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 关键字 | 7   | 14  |     | 8   |     | 11  | 30  | 18  | 9   |     |

参考：<https://www.cnblogs.com/ricklz/p/9006424.html>
