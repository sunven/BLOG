# 散列表

## 线性探测法

| Key    | 7    | 8    | 30   | 11   | 18   | 9    | 14   |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| H(Key) | 0    | 3    | 6    | 5    | 5    | 6    | 0    |

关键字7和14，30和9， 11和18，这三组关键子的H(Key)值相同，这在构建散列表时就会产生冲突

**步骤：**

1. 第一个key 7，它的地址是0，因此放到散列表的数组下表为0的位置，这个位置上没有关键字，因此没有冲突可以直接填入；
2. 第二个key 8，它的地址是3，因此放到散列表的数组下表为3的位置，这个位置上没有关键字，因此没有冲突可以直接填入；

1. 第三个key 30，它的地址是6，因此放到散列表的数组下表为6的位置，这个位置上没有关键字，因此没有冲突可以直接填入；
2. 第四个key 11，它的地址是5，因此放到散列表的数组下表为5的位置，这个位置上没有关键字，因此没有冲突可以直接填入；

1. 第五个key 18，它的地址是5，因此放到散列表的数组下表为5的位置，但这个位置上已经有关键字11，遇到了冲突，此时我们根据线性探测再散列法来处理这个冲突，探测下一个位置6, 6这个位置上已经存在关键字30则继续增加步长1，因此现在的新地址应为7，位置7上没有关键字，放入即可，到此冲突已经解决；
2.  第六个key 9，它的地址是6，因此放到散列表的数组下表为6的位置，但这个位置上已经有关键字30，遇到了冲突，探测下一个位置7, 7这个位置上已经存在关键字18则继续增加步长1，因此现在的新地址应为8，位置8上没有关键字，放入即可；   

1. 第七个key 14，它的地址是0，因此放到散列表的数组下表为0的位置，但这个位置上已经有关键字7，遇到了冲突，探测下一个位置1, 位置1上没有关键字，放入即可；

**结果：**

| 地址   | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 关键字 | 7    | 14   |      | 8    |      | 11   | 30   | 18   | 9    |      |

参考：https://www.cnblogs.com/ricklz/p/9006424.html