"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4913],{8703:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-242973e9",path:"/reading/professionaljavascript.html",title:"JavaScript高级程序设计",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"理解对象",slug:"理解对象",children:[{level:3,title:"数据属性",slug:"数据属性",children:[]},{level:3,title:"访问器属性",slug:"访问器属性",children:[]},{level:3,title:"定义多个属性",slug:"定义多个属性",children:[]},{level:3,title:"读取属性的特性Object.getOwnPropertyDescriptor",slug:"读取属性的特性object-getownpropertydescriptor",children:[]},{level:3,title:"创建对象",slug:"创建对象",children:[]},{level:3,title:"构造函数模式",slug:"构造函数模式",children:[]},{level:3,title:"原型模式",slug:"原型模式",children:[]},{level:3,title:"组合使用构造函数模式与原型模式",slug:"组合使用构造函数模式与原型模式",children:[]},{level:3,title:"动态原型模式",slug:"动态原型模式",children:[]},{level:3,title:"寄生构造函数模式",slug:"寄生构造函数模式",children:[]},{level:3,title:"稳妥构造函数模式",slug:"稳妥构造函数模式",children:[]}]}],filePathRelative:"reading/professionaljavascript.md",git:{updatedTime:1626107275e3,contributors:[{name:"sunven",email:"604164227@qq.com",commits:1}]}}},5363:(n,s,a)=>{a.r(s),a.d(s,{default:()=>r});const e=(0,a(6252).uE)('<h1 id="javascript高级程序设计" tabindex="-1"><a class="header-anchor" href="#javascript高级程序设计" aria-hidden="true">#</a> JavaScript高级程序设计</h1><h2 id="理解对象" tabindex="-1"><a class="header-anchor" href="#理解对象" aria-hidden="true">#</a> 理解对象</h2><h3 id="数据属性" tabindex="-1"><a class="header-anchor" href="#数据属性" aria-hidden="true">#</a> 数据属性</h3><ul><li><code>Configurable</code>:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值为<code>true</code>。</li><li><code>Enumerable</code>:表示能否通过for-in循环返回属性，默认值<code>true</code>。</li><li><code>Writable</code>:表示能否修改属性的值，默认值<code>true</code>。</li><li><code>Value</code>:包含这个属性的数据值。读取属性的时候，从这个位置读，写入属性的时候，吧新值保存在这个位置。默认是为<code>undefined</code>。</li></ul><blockquote><p>要修改属性的默认特性，必须使用ES5的Object.defineProperty()方法，这个方法接受三个参数：属性所在的对象，属性的名字和一个描述符对象。</p></blockquote><h4 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h4><h5 id="_1-writable-value" tabindex="-1"><a class="header-anchor" href="#_1-writable-value" aria-hidden="true">#</a> 1 writable,value</h5><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\nObject<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token string">&quot;name&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    writable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n    value<span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//&quot;Nicholas&quot;</span>\nperson<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Michael&quot;</span><span class="token punctuation">;</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//&quot;Nicholas&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h5 id="_2-configurable" tabindex="-1"><a class="header-anchor" href="#_2-configurable" aria-hidden="true">#</a> 2 configurable</h5><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var person = {};\nObject.defineProperty(person, &quot;name&quot;, {\n    configurable: false,\n    value: &quot;Nicholas&quot;\n});\nalert(person.name);//&quot;Nicholas&quot;\ndelete person.name;\nalert(person.name);//&quot;Nicholas&quot;\n\nvar person = {};\nObject.defineProperty(person, &quot;name&quot;, {\n    configurable: false,\n    value: &quot;Nicholas&quot;\n});\n//throws error\nObject.defineProperty(person, &quot;name&quot;, {\n    configurable: true,\n    value: &quot;Nicholas&quot;\n});\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><blockquote><p>一旦把属性定义为不可配置的，就不能再把它变回可配置了。</p></blockquote><h3 id="访问器属性" tabindex="-1"><a class="header-anchor" href="#访问器属性" aria-hidden="true">#</a> 访问器属性</h3><ul><li><code>Configurable</code>:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。默认值为<code>true</code>。</li><li><code>Enumerable</code>:表示能否通过for-in循环返回属性，默认值<code>true</code>。</li><li><code>Get</code>:在读取属性时调用的函数，默认值<code>undefined</code>。</li><li><code>Set</code>:在写入属性时调用的函数，默认值<code>undefined</code>。</li></ul><blockquote><p>访问器属性必须使用<code>Object.defineProperty()</code>来定义</p></blockquote><h4 id="例子-1" tabindex="-1"><a class="header-anchor" href="#例子-1" aria-hidden="true">#</a> 例子</h4><h5 id="_1" tabindex="-1"><a class="header-anchor" href="#_1" aria-hidden="true">#</a> 1</h5><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var book = {\n    _year: 2004,\n    edition: 1\n};\nObject.defineProperty(book, &quot;year&quot;, {\n    get: function(){\n        return this._year;\n    },\n    set: function(newValue){\n        if (newValue &gt; 2004) {\n            this._year = newValue;\n            this.edition += newValue - 2004;\n        }\n    }\n});\nbook.year = 2005;\nalert(book.edition);   //2\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><ul><li><p>_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。</p></li><li><p>getter和setter可以只指定一种，表示只读或者只写。</p></li></ul><h3 id="定义多个属性" tabindex="-1"><a class="header-anchor" href="#定义多个属性" aria-hidden="true">#</a> 定义多个属性</h3><p><code>Object.defineProperties()</code></p><h4 id="例子-2" tabindex="-1"><a class="header-anchor" href="#例子-2" aria-hidden="true">#</a> 例子</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var book = {};\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {            \n        get: function(){\n            return this._year;\n        },\n        \n        set: function(newValue){\n            if (newValue &gt; 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }                  \n        }            \n    }        \n});\nbook.year = 2005;\nalert(book.edition);   //2\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>两个数据属性（_year和edition）和一个访问器属性（year）</p><h3 id="读取属性的特性object-getownpropertydescriptor" tabindex="-1"><a class="header-anchor" href="#读取属性的特性object-getownpropertydescriptor" aria-hidden="true">#</a> 读取属性的特性<code>Object.getOwnPropertyDescriptor</code></h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var book = {};\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {            \n        get: function(){\n            return this._year;\n        },\n        \n        set: function(newValue){\n            if (newValue &gt; 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }                  \n        }            \n    }        \n});\nvar descriptor = Object.getOwnPropertyDescriptor(book, &quot;_year&quot;);\nalert(descriptor.value);          //2004\nalert(descriptor.configurable);   //false\nalert(typeof descriptor.get);     //&quot;undefined&quot;\n\nvar descriptor = Object.getOwnPropertyDescriptor(book, &quot;year&quot;);\nalert(descriptor.value);          //undefined\nalert(descriptor.enumerable);     //false\nalert(typeof descriptor.get);     //&quot;function&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><h3 id="创建对象" tabindex="-1"><a class="header-anchor" href="#创建对象" aria-hidden="true">#</a> 创建对象</h3><h4 id="工厂模式" tabindex="-1"><a class="header-anchor" href="#工厂模式" aria-hidden="true">#</a> 工厂模式</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function createPerson(name, age, job){\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function(){\n        alert(this.name);\n    };    \n    return o;\n}\nvar person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nperson1.sayName();   //&quot;Nicholas&quot;\nperson2.sayName();   //&quot;Greg&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><blockquote><p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p></blockquote><h3 id="构造函数模式" tabindex="-1"><a class="header-anchor" href="#构造函数模式" aria-hidden="true">#</a> 构造函数模式</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function(){\n        alert(this.name);\n    };    \n}\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nperson1.sayName();   //&quot;Nicholas&quot;\nperson2.sayName();   //&quot;Greg&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h4 id="与工厂模式的不同之处" tabindex="-1"><a class="header-anchor" href="#与工厂模式的不同之处" aria-hidden="true">#</a> 与工厂模式的不同之处</h4><ul><li>没有显示的创建对象</li><li>直接将属性和方法赋给了this对象</li><li>没有return语句</li></ul><blockquote><p>按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。</p></blockquote><p>创建一个新实例，必须使用new操作符，以这种方式调用构造函数会经历4个步骤：</p><ol><li>创建一个新对象；</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>返回新对象。</li></ol><h4 id="constructor属性" tabindex="-1"><a class="header-anchor" href="#constructor属性" aria-hidden="true">#</a> <code>constructor</code>属性</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>alert(person1.constructor == Person);  //true\nalert(person2.constructor == Person);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>constructor属性最初是用来标识对象类型的。但是检测对象类型，还是instanceof操作符更可靠一些</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>alert(person1 instanceof Object);  //true\nalert(person1 instanceof Person);  //true\nalert(person2 instanceof Object);  //true\nalert(person2 instanceof Person);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正式构造函数模式胜过工厂模式的地方</p></blockquote><h4 id="将构造函数当做函数" tabindex="-1"><a class="header-anchor" href="#将构造函数当做函数" aria-hidden="true">#</a> 将构造函数当做函数</h4><p>构造函数与其他函数的唯一区别，就是调用他们的方式不同。任何函数，只要通过new操作符调用，就可以当做构造函数；不通过new操作符调用，那就和普通函数一样。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>//当做构造函数使用\nvar person = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nperson.sayName();   //&quot;Nicholas&quot;\n\n//作为普通函数使用\nPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);  //adds to window\nwindow.sayName();   //&quot;Greg&quot;\n\n//在另一个对象的作用域中调用\nvar o = new Object();\nPerson.call(o, &quot;Kristen&quot;, 25, &quot;Nurse&quot;);\no.sayName();    //&quot;Kristen&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="构造函数的问题" tabindex="-1"><a class="header-anchor" href="#构造函数的问题" aria-hidden="true">#</a> 构造函数的问题</h4><h5 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h5><p>每个方法都要在每个实例上重新创建一遍，每个实例上的同名方法是不相等的。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>alert(person1.sayName == person2.sayName);  //false\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h5 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法" aria-hidden="true">#</a> 解决方法</h5><p>把函数定义转义到构造函数外部</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName;\n}\n\nfunction sayName(){\n    alert(this.name);\n}\n\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nalert(person1.sayName == person2.sayName);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h5 id="还是存在的问题" tabindex="-1"><a class="header-anchor" href="#还是存在的问题" aria-hidden="true">#</a> 还是存在的问题</h5><p>sayName方法只被Person的实例调用，但却定义成了全局函数，这样似乎有些大材小用；如果对象需要定义很多方法，那么就需要更多的全局函数，于是，自定义的应用类型就没有封装性可言了。</p><h5 id="解决方法-1" tabindex="-1"><a class="header-anchor" href="#解决方法-1" aria-hidden="true">#</a> 解决方法</h5><p>原型模式</p><h3 id="原型模式" tabindex="-1"><a class="header-anchor" href="#原型模式" aria-hidden="true">#</a> 原型模式</h3><p>我们创建的每一个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName();   //&quot;Nicholas&quot;\n\nvar person2 = new Person();\nperson2.sayName();   //&quot;Nicholas&quot;\n\nalert(person1.sayName == person2.sayName);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>与构造函数不同的是，新对象的这些属性和方法是由所有实例共享的。即：<code>person1.sayName == person2.sayName</code></p><h4 id="理解原型对象" tabindex="-1"><a class="header-anchor" href="#理解原型对象" aria-hidden="true">#</a> 理解原型对象</h4><ol><li>只要创建一个新函数，就会为改函数创建一个prototype属性，这个属性指向函数的原型对象。</li><li>默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。即：<code>Person.prototype.constructor</code>指向<code>Person</code>。</li><li>当调用构造与函数创建一个实例后，该实例内部将包含一个指针（内部属性），指向构造函数的原型对象。即：<code>[[Prototype]]</code>，浏览器中的<code>_proto_</code>。</li><li>这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。</li></ol><p><img src="https://raw.githubusercontent.com/sunven/picture/master/6-1.png" alt=""></p><p>虽然无法访问到[[Prototype]]，但是可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>alert(Person.prototype.isPrototypeOf(person1));  //true\nalert(Person.prototype.isPrototypeOf(person2));  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>ES5中，有一个Object.getProtoOf()方法，在所有支持的实现中，返回[[Prototype]]的值。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>if (Object.getPrototypeOf){\n    alert(Object.getPrototypeOf(person1) == Person.prototype);  //true\n    alert(Object.getPrototypeOf(person1).name);  //&quot;Nicholas&quot;\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>同名属性覆盖原型属性</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.name = &quot;Greg&quot;;\nalert(person1.name);   //&quot;Greg&quot; 来自实例\nalert(person2.name);   //&quot;Nicholas&quot; 来自原型\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>删除实例属性，重新访问原型属性</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.name = &quot;Greg&quot;;\nalert(person1.name);   //&quot;Greg&quot; 来自实例\nalert(person2.name);   //&quot;Nicholas&quot; 来自原型\n\ndelete person1.name;\nalert(person1.name);   //&quot;Nicholas&quot; 来自原型\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>使用hasOwnProperty()方法可以检测一个属性时存在实例中，还是原型中。这个方法只在给定属性存在于对象实例中时，才会返回true。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nalert(person1.hasOwnProperty(&quot;name&quot;));  //false\n\nperson1.name = &quot;Greg&quot;;\nalert(person1.name);   //&quot;Greg&quot; 来自实例\nalert(person1.hasOwnProperty(&quot;name&quot;));  //true\n\nalert(person2.name);   //&quot;Nicholas&quot; 来自原型\nalert(person2.hasOwnProperty(&quot;name&quot;));  //false\n\ndelete person1.name;\nalert(person1.name);   //&quot;Nicholas&quot; 来自原型\nalert(person1.hasOwnProperty(&quot;name&quot;));  //false\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><blockquote><p>ES5的<code>Object.getOwnPropertyDescriptor()</code>方法只能用于实例属性，要取得原型属性的描述符，必须直接在原型对象上调用<code>Object.getOwnPropertyDescriptor()</code>方法</p></blockquote><h4 id="原型与in操作符" tabindex="-1"><a class="header-anchor" href="#原型与in操作符" aria-hidden="true">#</a> 原型与in操作符</h4><p>有两种方式使用in操作符：</p><h5 id="_1-单独使用" tabindex="-1"><a class="header-anchor" href="#_1-单独使用" aria-hidden="true">#</a> 1. 单独使用</h5><p>无论属性存在于实例还是原型，都会返回true。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nalert(person1.hasOwnProperty(&quot;name&quot;));  //false\nalert(&quot;name&quot; in person1);  //true\n\nperson1.name = &quot;Greg&quot;;\nalert(person1.name);   //&quot;Greg&quot; 来自实例\nalert(person1.hasOwnProperty(&quot;name&quot;));  //true\nalert(&quot;name&quot; in person1);  //true\n\nalert(person2.name);   //&quot;Nicholas&quot; 来自原型\nalert(person2.hasOwnProperty(&quot;name&quot;));  //false\nalert(&quot;name&quot; in person2);  //true\n\ndelete person1.name;\nalert(person1.name);   //&quot;Nicholas&quot; - 来自原型\nalert(person1.hasOwnProperty(&quot;name&quot;));  //false\nalert(&quot;name&quot; in person1);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>使用<code>hasOwnProperty()</code>和<code>in</code>判断属性存在于对象还是原型</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function hasPrototypeProperty(object,name){\n    return !object.hasOwnProperty(name)&amp;&amp;(name in object);\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h5 id="_2-在for-in循环中使用" tabindex="-1"><a class="header-anchor" href="#_2-在for-in循环中使用" aria-hidden="true">#</a> 2. 在for-in循环中使用</h5><p>返回可枚举的属性</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>var o = {\n    toString : function(){\n        return &quot;My Object&quot;;\n    }\n}\n\nfor (var prop in o){\n    if (prop == &quot;toString&quot;){\n        alert(&quot;Found toString&quot;);\n    }\n}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>解释：toString()方法屏蔽了原型中的toString()方法，所以for-in可见。</p><h5 id="object-keys" tabindex="-1"><a class="header-anchor" href="#object-keys" aria-hidden="true">#</a> Object.keys()</h5><p>接收一个对象作为参数，返回包含所有可枚举属性的字符串数组</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype.name = &quot;Nicholas&quot;;\nPerson.prototype.age = 29;\nPerson.prototype.job = &quot;Software Engineer&quot;;\nPerson.prototype.sayName = function(){\n    alert(this.name);\n};\n\nvar keys = Object.keys(Person.prototype);\nalert(keys);   //&quot;name,age,job,sayName&quot;\n\nvar p1=new Person();\np1.name=&quot;Rob&quot;;\np1.age=31;\nvar keys=Object.keys(p1);\nalert(keys);    //&quot;name,age&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="object-getownpropertynames" tabindex="-1"><a class="header-anchor" href="#object-getownpropertynames" aria-hidden="true">#</a> Object.getOwnPropertyNames()</h5><p>返回所有实例属性</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">;</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">29</span><span class="token punctuation">;</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>job <span class="token operator">=</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">;</span>\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> keys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//&quot;constructor,name,age,job,sayName&quot;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="更简单的原型语法" tabindex="-1"><a class="header-anchor" href="#更简单的原型语法" aria-hidden="true">#</a> 更简单的原型语法</h4><p>对象字面量的形式</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype = {\n    name : &quot;Nicholas&quot;,\n    age : 29,\n    job: &quot;Software Engineer&quot;,\n    sayName : function () {\n        alert(this.name);\n    }\n};\n\nvar friend = new Person();\n\nalert(friend instanceof Object);  //true\nalert(friend instanceof Person);  //true\nalert(friend.constructor == Person);  //false\nalert(friend.constructor == Object);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h5 id="不同之处" tabindex="-1"><a class="header-anchor" href="#不同之处" aria-hidden="true">#</a> 不同之处</h5><p>constructor属性不再指向Person了。 这种方式本质上重写了pertotype对象，因此constructor属性就变成了新对象的constructor属性（指向Object构造函数）</p><h5 id="解决方法-2" tabindex="-1"><a class="header-anchor" href="#解决方法-2" aria-hidden="true">#</a> 解决方法</h5><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n<span class="token punctuation">}</span>\n\n<span class="token class-name">Person</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>\n    constructor <span class="token operator">:</span> Person<span class="token punctuation">,</span>\n    name <span class="token operator">:</span> <span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span>\n    age <span class="token operator">:</span> <span class="token number">29</span><span class="token punctuation">,</span>\n    job<span class="token operator">:</span> <span class="token string">&quot;Software Engineer&quot;</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">sayName</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> friend <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">alert</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//true</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>friend <span class="token keyword">instanceof</span> <span class="token class-name">Person</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//true</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Person<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//true</span>\n<span class="token function">alert</span><span class="token punctuation">(</span>friend<span class="token punctuation">.</span>constructor <span class="token operator">==</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//false</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>这种方法重设constructor属性会导致它的Enumerable特性被设置为true，默认情况下，原生的constructor属性时不可枚举的。</p><h4 id="原型的动态性" tabindex="-1"><a class="header-anchor" href="#原型的动态性" aria-hidden="true">#</a> 原型的动态性</h4><p>实例与原型之间的关系是松散的，因为实例与原型之间的连接只不过是一个指针。</p><p>如果重写了整个原型对象，就等于切断了构造函数与最初原型之间的联系。</p><p>实例中指针仅指向原型，而不指向构造函数。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nvar friend = new Person();\n        \nPerson.prototype = {\n    constructor: Person,\n    name : &quot;Nicholas&quot;,\n    age : 29,\n    job : &quot;Software Engineer&quot;,\n    sayName : function () {\n        alert(this.name);\n    }\n};\n\nfriend.sayName();   //error\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p><img src="https://raw.githubusercontent.com/sunven/picture/master/6-1.png" alt=""></p><p>重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，他们引用的任然是最初的原型。</p><h4 id="原生对象的原型" tabindex="-1"><a class="header-anchor" href="#原生对象的原型" aria-hidden="true">#</a> 原生对象的原型</h4><p>所有原生引用类型（Object，Array，String等）都在其构造函数的原型上定义了方法</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>alert(typeof Array.prototype.sort);         //&quot;function&quot;\nalert(typeof String.prototype.substring);   //&quot;function&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>修改原生对象的原型，但不推荐</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>String.prototype.startsWith = function (text) {\n    return this.indexOf(text) == 0;\n};\n\nvar msg = &quot;Hello world!&quot;;\nalert(msg.startsWith(&quot;Hello&quot;));   //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h4 id="原型对象的问题" tabindex="-1"><a class="header-anchor" href="#原型对象的问题" aria-hidden="true">#</a> 原型对象的问题</h4><p>原型中的所有属性是被很多实例共享的。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(){\n}\n\nPerson.prototype = {\n    constructor: Person,\n    name : &quot;Nicholas&quot;,\n    age : 29,\n    job : &quot;Software Engineer&quot;,\n    friends : [&quot;Shelby&quot;, &quot;Court&quot;],\n    sayName : function () {\n        alert(this.name);\n    }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(&quot;Van&quot;);\n\nalert(person1.friends);    //&quot;Shelby,Court,Van&quot;\nalert(person2.friends);    //&quot;Shelby,Court,Van&quot;\nalert(person1.friends === person2.friends);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="组合使用构造函数模式与原型模式" tabindex="-1"><a class="header-anchor" href="#组合使用构造函数模式与原型模式" aria-hidden="true">#</a> 组合使用构造函数模式与原型模式</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享属性。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];\n}\n\nPerson.prototype = {\n    constructor: Person,\n    sayName : function () {\n        alert(this.name);\n    }\n};\n\nvar person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nvar person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);\n\nperson1.friends.push(&quot;Van&quot;);\n\nalert(person1.friends);    //&quot;Shelby,Court,Van&quot;\nalert(person2.friends);    //&quot;Shelby,Court&quot;\nalert(person1.friends === person2.friends);  //false\nalert(person1.sayName === person2.sayName);  //true\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="动态原型模式" tabindex="-1"><a class="header-anchor" href="#动态原型模式" aria-hidden="true">#</a> 动态原型模式</h3><p>把所有信息都封装在构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数与原型的优点。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age, job){\n    //properties\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    \n    //methods\n    if (typeof this.sayName != &quot;function&quot;){\n    \n        Person.prototype.sayName = function(){\n            alert(this.name);\n        };\n        \n    }\n}\n\nvar friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nfriend.sayName();\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>注释methods下面的代码只会在初次调用构造函数的时候才会执行，此后，原型已经完成初始化。之后对原型的修改，也能立即在所有的实例中得到反映。</p><blockquote><p>使用动态原型模式时，不能使用对象字面量重写原型。如果在已经创建了实例的情况下重写原型，就会切断现有实例与新原型之间的联系。</p></blockquote><h3 id="寄生构造函数模式" tabindex="-1"><a class="header-anchor" href="#寄生构造函数模式" aria-hidden="true">#</a> 寄生构造函数模式</h3><p>这种模式基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。表面上看很像构造函数。</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name, age, job){\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function(){\n        alert(this.name);\n    };    \n    return o;\n}\n\nvar friend = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);\nfriend.sayName();  //&quot;Nicholas&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>除了使用new操作符，跟工厂模式又是一样的。</p><p>这个模式可以用来为对象创建构造函数</p><p>为Array添加一个额外的方法，而不修改Array的构造函数</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function SpecialArray(){       \n\n    //create the array\n    var values = new Array();\n    \n    //add the values\n    values.push.apply(values, arguments);\n    \n    //assign the method\n    values.toPipedString = function(){\n        return this.join(&quot;|&quot;);\n    };\n    \n    //return it\n    return values;        \n}\n\nvar colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);\nalert(colors.toPipedString()); //&quot;red|blue|green&quot;\n\nalert(colors instanceof SpecialArray);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h4><p>返回的对象与构造函数或者与构造函数的原型属性之间没有关系。</p><h3 id="稳妥构造函数模式" tabindex="-1"><a class="header-anchor" href="#稳妥构造函数模式" aria-hidden="true">#</a> 稳妥构造函数模式</h3><h4 id="特点-1" tabindex="-1"><a class="header-anchor" href="#特点-1" aria-hidden="true">#</a> 特点</h4><ol><li>没有公共属性</li><li>新创建对象的实例不引用this</li><li>不使用new操作符调用构造函数</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>function Person(name,age,job){\n    //创建要返回的对象\n    var o=new Object();\n    //可以在这里定义一些私有变量核函数\n    \n    //添加方法\n    o.sayName=function(){\n        alert(name);\n    }\n    \n    //返回对象\n    return o;\n}\n\nvar friend=new Person(&quot;Tom&quot;,20,&quot;abc&quot;);\nfriend.sayName();   //&quot;Tom&quot;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>除了使用sayName()方法，没有其他方法访问name的值。即变量friend中保存的是一个稳妥对象。</p>',135),r={render:function(n,s){return e}}}}]);