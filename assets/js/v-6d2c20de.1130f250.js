"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[8608],{7663:(e,r,a)=>{a.r(r),a.d(r,{data:()=>t});const t={key:"v-6d2c20de",path:"/develop/safe/csrf.html",title:"CSRF",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"例子",slug:"例子",children:[]},{level:2,title:"解决方法",slug:"解决方法",children:[{level:3,title:"验证 HTTP Referer",slug:"验证-http-referer",children:[]},{level:3,title:"在请求地址中添加 token 并验证",slug:"在请求地址中添加-token-并验证",children:[]},{level:3,title:"在 HTTP 头中自定义属性并验证",slug:"在-http-头中自定义属性并验证",children:[]}]}],filePathRelative:"develop/safe/csrf.md",git:{updatedTime:1626107275e3,contributors:[{name:"sunven",email:"604164227@qq.com",commits:1}]}}},6922:(e,r,a)=>{a.r(r),a.d(r,{default:()=>c});var t=a(6252);const l=(0,t.uE)('<h1 id="csrf" tabindex="-1"><a class="header-anchor" href="#csrf" aria-hidden="true">#</a> CSRF</h1><h2 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h2><ol><li><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</code> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。</p></li><li><p>通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p></li><li><p>黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。</p></li><li><p>但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p></li><li><p>这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： <code>src=”http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory ”</code>，并且通过广告等诱使 Bob 来访问他的网站。</p></li><li><p>当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。</p></li><li><p>大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。</p></li><li><p>但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。</p></li><li><p>这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。</p></li><li><p>等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外</p></li></ol>',3),o={href:"https://en.wikipedia.org/wiki/Cross-site_request_forgery",target:"_blank",rel:"noopener noreferrer"},i=(0,t.Uk)("Cross-site request forgery"),n={href:"https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/",target:"_blank",rel:"noopener noreferrer"},h=(0,t.Uk)("CSRF 攻击的应对之道"),s={href:"https://docs.microsoft.com/zh-cn/aspnet/web-api/overview/security/preventing-cross-site-request-forgery-csrf-attacks",target:"_blank",rel:"noopener noreferrer"},p=(0,t.Uk)("阻止 ASP.NET MVC 应用程序中的跨站点请求伪造 (CSRF) 攻击"),d=(0,t.uE)('<h2 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法" aria-hidden="true">#</a> 解决方法</h2><h3 id="验证-http-referer" tabindex="-1"><a class="header-anchor" href="#验证-http-referer" aria-hidden="true">#</a> 验证 HTTP Referer</h3><p>Referer易被篡改</p><h3 id="在请求地址中添加-token-并验证" tabindex="-1"><a class="header-anchor" href="#在请求地址中添加-token-并验证" aria-hidden="true">#</a> 在请求地址中添加 token 并验证</h3><h3 id="在-http-头中自定义属性并验证" tabindex="-1"><a class="header-anchor" href="#在-http-头中自定义属性并验证" aria-hidden="true">#</a> 在 HTTP 头中自定义属性并验证</h3>',5),c={render:function(e,r){const a=(0,t.up)("OutboundLink");return(0,t.wg)(),(0,t.iD)(t.HY,null,[l,(0,t._)("p",null,[(0,t._)("a",o,[i,(0,t.Wm)(a)])]),(0,t._)("p",null,[(0,t._)("a",n,[h,(0,t.Wm)(a)])]),(0,t._)("p",null,[(0,t._)("a",s,[p,(0,t.Wm)(a)])]),d],64)}}}}]);