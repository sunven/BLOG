"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[936],{6168:(e,i,n)=>{n.r(i),n.d(i,{data:()=>r});const r={key:"v-e7489094",path:"/dotnet/designpatterns/principles.html",title:"设计原则",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"SRP(Single Responsibilities Principle)",slug:"srp-single-responsibilities-principle",children:[]},{level:2,title:"OCP(Open-Close Principle)",slug:"ocp-open-close-principle",children:[]},{level:2,title:"LSP(Liskov Substitution Principle)",slug:"lsp-liskov-substitution-principle",children:[{level:3,title:"reference",slug:"reference",children:[]}]},{level:2,title:"DIP(Dependence Inversion Principle)",slug:"dip-dependence-inversion-principle",children:[]},{level:2,title:"ISP(Interface Segregation Principle)",slug:"isp-interface-segregation-principle",children:[]},{level:2,title:"CRP(Composite Reuse Principle)",slug:"crp-composite-reuse-principle",children:[]},{level:2,title:"LoD(Law of Demeter) LKP(Least Knowledge Principle)",slug:"lod-law-of-demeter-lkp-least-knowledge-principle",children:[]}],filePathRelative:"dotnet/designpatterns/principles.md",git:{updatedTime:1626107275e3,contributors:[{name:"sunven",email:"604164227@qq.com",commits:1}]}}},2354:(e,i,n)=>{n.r(i),n.d(i,{default:()=>o});var r=n(6252);const l=(0,r.uE)('<h1 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h1><h2 id="srp-single-responsibilities-principle" tabindex="-1"><a class="header-anchor" href="#srp-single-responsibilities-principle" aria-hidden="true">#</a> SRP(Single Responsibilities Principle)</h2><h2 id="ocp-open-close-principle" tabindex="-1"><a class="header-anchor" href="#ocp-open-close-principle" aria-hidden="true">#</a> OCP(Open-Close Principle)</h2><h2 id="lsp-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#lsp-liskov-substitution-principle" aria-hidden="true">#</a> LSP(Liskov Substitution Principle)</h2><blockquote><p>使用基类对象指针或引用的函数必须能够在不了解衍生类的条件下使用衍生类的对象 如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都换成o2时，程序P的行为没有变化，那么类型T2是类型T1的子类型 子类可以扩展父类的功能，但不能改变父类原有的功能</p></blockquote><ol><li>子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ol><h3 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> reference</h3>',7),t={href:"http://www.cnblogs.com/gaochundong/p/liskov_substitution_principle.html",target:"_blank",rel:"noopener noreferrer"},p=(0,r.Uk)("里氏替换原则（Liskov Substitution Principle）"),a={href:"http://www.cnblogs.com/hellojava/archive/2013/03/15/2960905.html",target:"_blank",rel:"noopener noreferrer"},s=(0,r.Uk)("设计模式六大原则（2）：里氏替换原则"),c=(0,r.uE)('<h2 id="dip-dependence-inversion-principle" tabindex="-1"><a class="header-anchor" href="#dip-dependence-inversion-principle" aria-hidden="true">#</a> DIP(Dependence Inversion Principle)</h2><h2 id="isp-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#isp-interface-segregation-principle" aria-hidden="true">#</a> ISP(Interface Segregation Principle)</h2><h2 id="crp-composite-reuse-principle" tabindex="-1"><a class="header-anchor" href="#crp-composite-reuse-principle" aria-hidden="true">#</a> CRP(Composite Reuse Principle)</h2><h2 id="lod-law-of-demeter-lkp-least-knowledge-principle" tabindex="-1"><a class="header-anchor" href="#lod-law-of-demeter-lkp-least-knowledge-principle" aria-hidden="true">#</a> LoD(Law of Demeter) LKP(Least Knowledge Principle)</h2>',4),o={render:function(e,i){const n=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.iD)(r.HY,null,[l,(0,r._)("p",null,[(0,r._)("a",t,[p,(0,r.Wm)(n)])]),(0,r._)("p",null,[(0,r._)("a",a,[s,(0,r.Wm)(n)])]),c],64)}}}}]);