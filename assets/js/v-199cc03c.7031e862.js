"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[4172],{1282:(n,s,a)=>{a.r(s),a.d(s,{data:()=>p});const p={key:"v-199cc03c",path:"/web/js/classandmodule.html",title:"类和模块",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"一 类和原型",slug:"一-类和原型",children:[]},{level:2,title:"二 类和构造函数",slug:"二-类和构造函数",children:[{level:3,title:"构造函数和类的标识",slug:"构造函数和类的标识",children:[]},{level:3,title:"constructor属性",slug:"constructor属性",children:[]}]},{level:2,title:"三 JavaScript中Java式的类继承",slug:"三-javascript中java式的类继承",children:[]},{level:2,title:"四 类的扩充",slug:"四-类的扩充",children:[]},{level:2,title:"五 类和类型",slug:"五-类和类型",children:[{level:3,title:"instanceof运算符",slug:"instanceof运算符",children:[]},{level:3,title:"constructor 属性",slug:"constructor-属性",children:[]}]}],filePathRelative:"web/js/classandmodule.md",git:{updatedTime:1626107275e3,contributors:[{name:"sunven",email:"604164227@qq.com",commits:1}]}}},4185:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});const p=(0,a(6252).uE)('<h1 id="类和模块" tabindex="-1"><a class="header-anchor" href="#类和模块" aria-hidden="true">#</a> 类和模块</h1><h2 id="一-类和原型" tabindex="-1"><a class="header-anchor" href="#一-类和原型" aria-hidden="true">#</a> 一 类和原型</h2><h2 id="二-类和构造函数" tabindex="-1"><a class="header-anchor" href="#二-类和构造函数" aria-hidden="true">#</a> 二 类和构造函数</h2><p>调用构造函数的一个重要特征是，构造函数的prototye属性被用做新对象的原型。这意味着通过同一个构造函数创建的所有对象都继承自一个相同的对象，因此它们都是同一个类的成员</p><h3 id="构造函数和类的标识" tabindex="-1"><a class="header-anchor" href="#构造函数和类的标识" aria-hidden="true">#</a> 构造函数和类的标识</h3><p>原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，它们才是属于同一个类的实例 两个构造函数的prototype属性可能指向同一个原型对象。那么这两个构造函数创建的实例是属于同一个类的。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>r <span class="token keyword">instanceof</span> <span class="token class-name">Range</span><span class="token comment">//如果r继承自Range.prototype，则返回true</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="constructor属性" tabindex="-1"><a class="header-anchor" href="#constructor属性" aria-hidden="true">#</a> constructor属性</h3><p>任何JavaScript函数都可以用做构造函数，并且调用构造函数是需要用到一个prototye属性的。因此，每个JavaScript函数（ECMAScript 5中的Function.bind()方法返回的函数除外）都自动拥有一个prototype属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性constructor。constructor属性的值是一个函数对象：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">F</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//这是一个函数对象</span>\n<span class="token keyword">var</span> p<span class="token operator">=</span><span class="token class-name">F</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment">//这是F相关联的原型对象</span>\n<span class="token keyword">var</span> c<span class="token operator">=</span>p<span class="token punctuation">.</span>constructor<span class="token punctuation">;</span><span class="token comment">//这是与原型相关联的函数</span>\nc<span class="token operator">===</span><span class="token constant">F</span><span class="token comment">//=＞true:对于任意函数F.prototype.constructor==F</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>构造函数的原型中存在预先定义好的constructor属性，这意味着对象通常继承的constructor均指代它们的构造函数。由于构造函数是类的“公共标识”，因此这个constructor属性为对象提供了类。</p><p>显式给原型添加一个构造函数</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Range</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>\n    constructor<span class="token operator">:</span> Range<span class="token punctuation">,</span> <span class="token comment">//显式设置构造函数反向引用</span>\n    <span class="token function-variable function">includes</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>from＜ <span class="token operator">=</span> x＆＆ x＜ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">foreach</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> x＜ <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token string">&quot;(&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">+</span> <span class="token string">&quot;...&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">+</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>使用预定义的原型对象</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//扩展预定义的Range.prototype对象，而不重写之</span>\n<span class="token comment">//这样就自动创建Range.prototype.constructor属性</span>\n<span class="token class-name">Range</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">includes</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">&lt;=</span> x <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token class-name">Range</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">foreach</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> x <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token class-name">Range</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token string">&quot;(&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>from <span class="token operator">+</span> <span class="token string">&quot;...&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>to <span class="token operator">+</span> <span class="token string">&quot;)&quot;</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="三-javascript中java式的类继承" tabindex="-1"><a class="header-anchor" href="#三-javascript中java式的类继承" aria-hidden="true">#</a> 三 JavaScript中Java式的类继承</h2><p>三种类成员</p><ul><li>构造函数对象</li></ul><p>构造函数（对象）为JavaScript的类定义了名字。任何添加到这个构造函数对象中的属性都是类字段和类方法（如果属性值是函数的话就是类方法）</p><ul><li>原型对象</li></ul><p>原型对象的属性被类的所有实例所继承，如果原型对象的属性值是函数的话，这个函数就作为类的实例的方法来调用</p><ul><li>实例对象</li></ul><p>类的每个实例都是一个独立的对象，直接给这个实例定义的属性是不会为所有实例对象所共享的。定义在实例上的非函数属性，实际上是实例的字段</p><p>定义类分三步</p><ul><li>第一步，先定义一个构造函数，并设置初始化新对象的实例属性。</li><li>第二步，给构造函数的prototype对象定义实例的方法。</li><li>第三步，给构造函数定义类字段和类属性。</li></ul><h2 id="四-类的扩充" tabindex="-1"><a class="header-anchor" href="#四-类的扩充" aria-hidden="true">#</a> 四 类的扩充</h2><p>JavaScript中基于原型的继承机制是动态的：对象从其原型继承属性，如果创建对象之后原型的属性发生改变，也会影响到继承这个原型的所有实例对象。这意味着我们可以通过给原型对象添加新方法来扩充JavaScript类</p><h2 id="五-类和类型" tabindex="-1"><a class="header-anchor" href="#五-类和类型" aria-hidden="true">#</a> 五 类和类型</h2><h3 id="instanceof运算符" tabindex="-1"><a class="header-anchor" href="#instanceof运算符" aria-hidden="true">#</a> instanceof运算符</h3><p>左操作数是待检测其类的对象，右操作数是定义类的构造函数</p><p>检测对象的原型链上是否存在某个特定的原型对象</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>range<span class="token punctuation">.</span>methods<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//range.method是原型对象</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名 多窗口和多框架子页面的Web应用中兼容性不佳</p><h3 id="constructor-属性" tabindex="-1"><a class="header-anchor" href="#constructor-属性" aria-hidden="true">#</a> constructor 属性</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">typeAndValue</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span> <span class="token comment">//Null和undefined没有构造函数</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>constructor<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">case</span> Number<span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;Number:&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token comment">//处理原始类型</span>\n        <span class="token keyword">case</span> String<span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;String:&#39;&quot;</span> <span class="token operator">+</span> x <span class="token operator">+</span> <span class="token string">&quot;&#39;&quot;</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> Date<span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;Date:&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token comment">//处理内置类型</span>\n        <span class="token keyword">case</span> RegExp<span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;Regexp:&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">;</span>\n        <span class="token keyword">case</span> Complex<span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;Complex:&quot;</span> <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token comment">//处理自定义类型</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">//关键字case后的表达式都是函数，如果改用typeof运算符或获取到对象的class属性的话，它们应当改为字符串。</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>不足</p><ul><li>多个执行上下文的场景中它是无法正常工作的（比如在浏览器窗口的多个框架子页面中）</li><li>在JavaScript中也并非所有的对象都包含constructor属性</li></ul>',37),t={render:function(n,s){return p}}}}]);