"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[870],{6036:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-36e68b63",path:"/docker/intro.html",title:"Docker",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"安装",slug:"安装",children:[]},{level:2,title:"镜像加速",slug:"镜像加速",children:[]},{level:2,title:"常用命令",slug:"常用命令",children:[{level:3,title:"帮助命令",slug:"帮助命令",children:[]}]},{level:2,title:"镜像命令",slug:"镜像命令",children:[{level:3,title:"1. docker images",slug:"_1-docker-images",children:[]},{level:3,title:"2. docker search",slug:"_2-docker-search",children:[]},{level:3,title:"3. docker pull",slug:"_3-docker-pull",children:[]},{level:3,title:"4. docker rmi",slug:"_4-docker-rmi",children:[]},{level:3,title:"5. docker commit",slug:"_5-docker-commit",children:[]}]},{level:2,title:"容器命令",slug:"容器命令",children:[{level:3,title:"1. 新建容器并启动",slug:"_1-新建容器并启动",children:[]},{level:3,title:"2. 列出容器",slug:"_2-列出容器",children:[]},{level:3,title:"3. 退出容器",slug:"_3-退出容器",children:[]},{level:3,title:"4. 删除容器",slug:"_4-删除容器",children:[]},{level:3,title:"5. 后台启动容器",slug:"_5-后台启动容器",children:[]},{level:3,title:"6. 查看日志",slug:"_6-查看日志",children:[]},{level:3,title:"7. 容器中进程信息ps",slug:"_7-容器中进程信息ps",children:[]},{level:3,title:"8. 查看镜像的元数据",slug:"_8-查看镜像的元数据",children:[]},{level:3,title:"9. 进入当前正在运行的容器",slug:"_9-进入当前正在运行的容器",children:[]},{level:3,title:"10 .从容器内拷贝到主机",slug:"_10-从容器内拷贝到主机",children:[]},{level:3,title:"11. 其他",slug:"_11-其他",children:[]}]},{level:2,title:"容器数据卷",slug:"容器数据卷",children:[{level:3,title:"1. -v 挂载",slug:"_1-v-挂载",children:[]},{level:3,title:"2. mysql数据持久化",slug:"_2-mysql数据持久化",children:[]},{level:3,title:"3. 具名匿名挂载",slug:"_3-具名匿名挂载",children:[]},{level:3,title:"4. 数据卷容器",slug:"_4-数据卷容器",children:[]}]},{level:2,title:"Dockerfile",slug:"dockerfile",children:[{level:3,title:"Dockerfile指令",slug:"dockerfile指令",children:[]},{level:3,title:"CMD与ENTRYPOINT",slug:"cmd与entrypoint",children:[]}]},{level:2,title:"Docker网络",slug:"docker网络",children:[{level:3,title:"1. 原理",slug:"_1-原理",children:[]},{level:3,title:"2. --link",slug:"_2-link",children:[]},{level:3,title:"3. 自定义网络",slug:"_3-自定义网络",children:[]},{level:3,title:"4. 网络联通",slug:"_4-网络联通",children:[]},{level:3,title:"5.测试",slug:"_5-测试",children:[]}]},{level:2,title:"Docker Compose",slug:"docker-compose",children:[]},{level:2,title:"Docker Swarm",slug:"docker-swarm",children:[{level:3,title:"Manager nodes",slug:"manager-nodes",children:[]},{level:3,title:"Worker nodes",slug:"worker-nodes",children:[]},{level:3,title:"命令",slug:"命令",children:[]},{level:3,title:"service如何工作",slug:"service如何工作",children:[]},{level:3,title:"任务和调度",slug:"任务和调度",children:[]},{level:3,title:"副本和服务",slug:"副本和服务",children:[]}]},{level:2,title:"reference",slug:"reference",children:[]}],filePathRelative:"docker/intro.md",git:{updatedTime:1626352348e3,contributors:[{name:"sunven",email:"604164227@qq.com",commits:1}]}}},1278:(n,s,a)=>{a.r(s),a.d(s,{default:()=>d});var e=a(6252);const l=(0,e.uE)('<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> Docker</h1><h2 id="安装" tabindex="-1"><a class="header-anchor" href="#安装" aria-hidden="true">#</a> 安装</h2><h2 id="镜像加速" tabindex="-1"><a class="header-anchor" href="#镜像加速" aria-hidden="true">#</a> 镜像加速</h2><h2 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h2><h3 id="帮助命令" tabindex="-1"><a class="header-anchor" href="#帮助命令" aria-hidden="true">#</a> 帮助命令</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker version     <span class="token comment">#显示docker的版本信息。</span>\ndocker info        <span class="token comment">#显示docker的系统信息，包括镜像和容器的数量,更详细</span>\ndocker 命令 --help  <span class="token comment">#帮助命令</span>\n\n<span class="token comment">#例如：方便查看语法格式，可选参数等，十分爽到</span>\ndocker images --help\ndocker search --help\ndocker pull\t--help\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="镜像命令" tabindex="-1"><a class="header-anchor" href="#镜像命令" aria-hidden="true">#</a> 镜像命令</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker images <span class="token comment">#查看所有本地主机上的镜像</span>\ndocker search <span class="token comment">#搜索镜像</span>\ndocker pull   <span class="token comment">#下载镜像</span>\ndocker rmi    <span class="token comment">#删除镜像</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_1-docker-images" tabindex="-1"><a class="header-anchor" href="#_1-docker-images" aria-hidden="true">#</a> 1. docker images</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker images\nREPOSITORY    TAG       IMAGE ID       CREATED        SIZE\nhello-world   latest    d1165f221234   <span class="token number">3</span> months ago   <span class="token number">13</span>.3kB\n\n<span class="token comment">#1.解释</span>\n<span class="token comment">#REPOSITORY\t\t\t# 镜像的仓库源</span>\n<span class="token comment">#TAG\t\t\t\t    # 镜像的标签(版本)\t\t---lastest 表示最新版本</span>\n<span class="token comment">#IMAGE ID\t\t\t  # 镜像的id</span>\n<span class="token comment">#CREATED\t\t\t  # 镜像的创建时间</span>\n<span class="token comment">#SIZE\t\t\t\t    # 镜像的大小</span>\n\n<span class="token comment">#2.可选项（常用的2个）</span>\nOptions:\n  -a, --all         Show all images <span class="token punctuation">(</span>default hides intermediate images<span class="token punctuation">)</span> <span class="token comment">#列出所有镜像</span>\n  -q, --quiet       Only show numeric IDs <span class="token comment"># 只显示镜像的id</span>\n  \n<span class="token comment">#3.示例</span>\n<span class="token comment"># docker images -a  #列出所有镜像详细信息</span>\n<span class="token comment"># docker images -aq #列出所有镜像的id</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="_2-docker-search" tabindex="-1"><a class="header-anchor" href="#_2-docker-search" aria-hidden="true">#</a> 2. docker search</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># docker search mysql</span>\n\n<span class="token comment">#1.可选参数filter</span>\nOptions:\n  -f, --filter filter   Filter output based on conditions provided\n      --format string   Pretty-print search using a Go template\n      --limit int       Max number of search results <span class="token punctuation">(</span>default <span class="token number">25</span><span class="token punctuation">)</span>\n      --no-trunc        Don&#39;t truncate output\n<span class="token comment"># --filter=STARS=3000   #过滤，搜索出来的镜像收藏STARS数量大于3000的</span>\n\n<span class="token comment">#2.示例：</span>\n<span class="token comment"># docker search mysql --filter=STARS=3000</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="_3-docker-pull" tabindex="-1"><a class="header-anchor" href="#_3-docker-pull" aria-hidden="true">#</a> 3. docker pull</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 下载镜像 docker pull 镜像名[:tag]</span>\n<span class="token comment"># 上方的tag表示的是镜像的版本，如果不加就是默认下载的最新版</span>\n<span class="token comment"># docker pull mysql</span>\nUsing default tag: latest           <span class="token comment">#下载的最新版</span>\nlatest: Pulling from library/mysql\n69692152171a: Pull complete         <span class="token comment">#分层下载： docker image 的核心 联合文件系统</span>\n1651b0be3df3: Pull complete \n951da7386bc8: Pull complete \n0f86c95aa242: Pull complete \n37ba2d8bd4fe: Pull complete \n6d278bb05e94: Pull complete \n497efbd93a3e: Pull complete \nf7fddf10c2c2: Pull complete \n16415d159dfb: Pull complete \n0e530ffc6b73: Pull complete \nb0a4a1a77178: Pull complete \ncd90f92aa9ef: Pull complete \nDigest: sha256:d50098d7fcb25b1fcb24e2d3247cae3fc55815d64fec640dc395840f8fa80969 <span class="token comment">#签名，防伪标志</span>\nStatus: Downloaded newer image <span class="token keyword">for</span> mysql:latest\ndocker.io/library/mysql:latest <span class="token comment">#真实地址</span>\n\n<span class="token comment">#知道真实地址：</span>\n<span class="token comment">#所以docker pull mysql等价于docker pull docker.io/library/mysql:latest</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h3 id="_4-docker-rmi" tabindex="-1"><a class="header-anchor" href="#_4-docker-rmi" aria-hidden="true">#</a> 4. docker rmi</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1.首先我们查询出docker中的镜像</span>\n<span class="token comment"># docker images</span>\nREPOSITORY    TAG       IMAGE ID       CREATED        SIZE\nmysql         <span class="token number">5.7</span>       2c9028880e58   <span class="token number">4</span> weeks ago    447MB\nmysql         latest    c0cdc95609f1   <span class="token number">4</span> weeks ago    556MB\nhello-world   latest    d1165f221234   <span class="token number">3</span> months ago   <span class="token number">13</span>.3kB\n\n<span class="token comment">#2.删除镜像，可以通过REPOSITORY或者IMAGE ID来删除</span>\ndocker rmi -f 镜像id <span class="token comment">#删除指定id的镜像</span>\n<span class="token comment">#咱们尝试通过mysql5.7的image id来删除它</span>\n<span class="token punctuation">[</span>root@iZ2vc28obhvfham8wewhh0Z ~<span class="token punctuation">]</span><span class="token comment"># docker rmi -f 2c9028880e58</span>\nUntagged: mysql:5.7\nUntagged: mysql@sha256:a682e3c78fc5bd941e9db080b4796c75f69a28a8cad65677c23f7a9f18ba21fa\nDeleted: sha256:2c9028880e5814e8923c278d7e2059f9066d56608a21cd3f83a01e3337bacd68\nDeleted: sha256:c49c5c776f1bc87cdfff451ef39ce16a1ef45829e10203f4d9a153a6889ec15e\nDeleted: sha256:8345316eca77700e62470611446529113579712a787d356e5c8656a41c244aee\nDeleted: sha256:8ae51b87111404bd3e3bde4115ea2fe3fd2bb2cf67158460423c361a24df156b\nDeleted: sha256:9d5afda6f6dcf8dd59aef5c02099f1d3b3b0c9ae4f2bb7a61627613e8cdfe562\n\n<span class="token comment">#3.了解删除全部镜像的命令</span>\ndocker rmi -f <span class="token variable"><span class="token variable">$(</span>docker images -aq<span class="token variable">)</span></span> <span class="token comment">#删除全部的镜像</span>\n<span class="token comment">#通过docker images -aq查询出来的所有镜像进行删除</span>\n\n<span class="token comment"># docker images -aq | xargs docker rmi</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="_5-docker-commit" tabindex="-1"><a class="header-anchor" href="#_5-docker-commit" aria-hidden="true">#</a> 5. docker commit</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 命令和git原理类似</span>\ndocker commit -m<span class="token operator">=</span><span class="token string">&quot;描述信息&quot;</span> -a<span class="token operator">=</span><span class="token string">&quot;作者名字&quot;</span> 容器id 目标镜像名:<span class="token punctuation">[</span>版本TAG<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="容器命令" tabindex="-1"><a class="header-anchor" href="#容器命令" aria-hidden="true">#</a> 容器命令</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run 镜像id     <span class="token comment">#新建容器并启动</span>\ndocker <span class="token function">ps</span>             <span class="token comment">#列出所有运行的容器 docker container list</span>\ndocker <span class="token function">rm</span> 容器id      <span class="token comment">#删除指定容器</span>\ndocker start 容器id\t  <span class="token comment">#启动容器</span>\ndocker restart 容器id <span class="token comment">#重启容器</span>\ndocker stop 容器id\t  <span class="token comment">#停止当前正在运行的容器</span>\ndocker <span class="token function">kill</span> 容器id\t  <span class="token comment">#强制停止当前容器</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_1-新建容器并启动" tabindex="-1"><a class="header-anchor" href="#_1-新建容器并启动" aria-hidden="true">#</a> 1. 新建容器并启动</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> image <span class="token operator">|</span> docker container run <span class="token punctuation">[</span>可选参数<span class="token punctuation">]</span> image \n<span class="token comment">#参数说明</span>\n--name<span class="token operator">=</span><span class="token string">&quot;Name&quot;</span>\t\t<span class="token comment">#容器名字，比如：tomcat01 tomcat02 用来区分容器</span>\n-d\t\t\t\t\t    <span class="token comment">#后台方式运行</span>\n-it \t\t\t\t    <span class="token comment">#使用交互方式运行，进入容器查看内容</span>\n-p\t\t\t\t\t    <span class="token comment">#指定容器的端口，-p 8080(宿主机):8080(容器)</span>\n  <span class="token comment">#-p，这个是小写p。主要用法有几种：</span>\n\t<span class="token comment">#1.-p\t主机端口：容器端口（常用）</span>\n\t<span class="token comment">#2.-p\t容器端口</span>\n\t<span class="token comment">#3.容器端口</span>\n\t<span class="token comment">#4.-p\tip：主机端口：容器端口</span>\n-P\t\t\t\t\t<span class="token comment">#大写P，随机指定端口</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>例子：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1.使用命令运行并进入容器，通过的是bash命令</span>\n<span class="token comment"># docker run -it centos bin/bash</span>\n<span class="token comment"># ls</span>\nbin  etc   lib\t  lost+found  mnt  proc  run   srv  tmp  var\ndev  home  lib64  media       opt  root  sbin  sys  usr\n<span class="token comment">#4.退出容器到主机</span>\n<span class="token comment"># exit</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_2-列出容器" tabindex="-1"><a class="header-anchor" href="#_2-列出容器" aria-hidden="true">#</a> 2. 列出容器</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">ps</span> 命令  \t\t <span class="token comment">#列出当前正在运行的容器</span>\n  -a, --all     \t   <span class="token comment">#列出当前正在运行的容器 + 历史运行过的容器</span>\n  -n<span class="token operator">=</span>?, --last int   <span class="token comment">#列出最近创建的?个容器 ?为1则只列出最近创建的一个容器,为2则列出2个</span>\n  -q, --quiet        <span class="token comment">#只列出容器的编号</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_3-退出容器" tabindex="-1"><a class="header-anchor" href="#_3-退出容器" aria-hidden="true">#</a> 3. 退出容器</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">exit</span> \t\t    <span class="token comment">#容器直接退出</span>\nctrl +P +Q  <span class="token comment">#容器不停止退出 \t---注意：这个很有用的操作</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_4-删除容器" tabindex="-1"><a class="header-anchor" href="#_4-删除容器" aria-hidden="true">#</a> 4. 删除容器</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">rm</span> 容器id   \t\t\t\t        <span class="token comment">#删除指定的容器，不能删除正在运行的容器，如果要强制删除 rm -rf</span>\ndocker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span>  \t <span class="token comment">#删除所有的容器，又是参数传递方式，搜出来的结果删</span>\ndocker <span class="token function">ps</span> -a -q<span class="token operator">|</span><span class="token function">xargs</span> docker <span class="token function">rm</span>  <span class="token comment">#删除所有的容器</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_5-后台启动容器" tabindex="-1"><a class="header-anchor" href="#_5-后台启动容器" aria-hidden="true">#</a> 5. 后台启动容器</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1.后台运行centos</span>\n<span class="token comment"># docker run -d centos</span>\ndfec0e9a77be8a277779477dc0d5d74b2be42e182cd4cd62efa92547f6833b3a\n<span class="token comment">#2.查看运行中的容器，发现没有</span>\n<span class="token comment"># docker ps</span>\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\n<span class="token comment"># 问题docker ps. 发现centos 停止了</span>\n<span class="token comment"># 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止。</span>\n<span class="token comment">#Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行ping，sleep），就是会自动退出的。</span>\n<span class="token comment">#（这样想docker发现启动了也提供不了服务，没有东西需要它就自己关闭了，即是快速开，快速关）</span>\n<span class="token comment"># 比如nginx，容器启动后，发现自己没有提供服务，就会立刻停止自杀，就是没有程序了</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_6-查看日志" tabindex="-1"><a class="header-anchor" href="#_6-查看日志" aria-hidden="true">#</a> 6. 查看日志</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1.查看</span>\ndocker logs --help\n<span class="token comment">#可选项</span>\nOptions:\n      --details        Show extra details provided to logs \n  -f, --follow         Follow log output\n      --since string   Show logs since timestamp <span class="token punctuation">(</span>e.g. <span class="token number">2013</span>-01-02T13:23:37<span class="token punctuation">)</span> or relative <span class="token punctuation">(</span>e.g. 42m <span class="token keyword">for</span> <span class="token number">42</span> minutes<span class="token punctuation">)</span>\n      --tail string    Number of lines to show from the end of the logs <span class="token punctuation">(</span>default <span class="token string">&quot;all&quot;</span><span class="token punctuation">)</span>\n  -t, --timestamps     Show timestamps\n      --until string   Show logs before a timestamp <span class="token punctuation">(</span>e.g. <span class="token number">2013</span>-01-02T13:23:37<span class="token punctuation">)</span> or relative <span class="token punctuation">(</span>e.g. 42m <span class="token keyword">for</span> <span class="token number">42</span> minutes<span class="token punctuation">)</span>\n      \n<span class="token comment"># docker run -d centos /bin/sh -c &quot;while true;do echo 6666;sleep 1;done&quot; #模拟日志 </span>\n\n<span class="token comment">#2.显示日志</span>\n-tf\t\t                         <span class="token comment">#显示日志信息（一直更新）</span>\n--tail number                  <span class="token comment">#需要显示日志条数</span>\ndocker logs -t --tail n 容器id <span class="token comment">#查看n行日志</span>\ndocker logs -ft 容器id         <span class="token comment">#跟着日志</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h3 id="_7-容器中进程信息ps" tabindex="-1"><a class="header-anchor" href="#_7-容器中进程信息ps" aria-hidden="true">#</a> 7. 容器中进程信息ps</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker <span class="token function">top</span> 容器id\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="_8-查看镜像的元数据" tabindex="-1"><a class="header-anchor" href="#_8-查看镜像的元数据" aria-hidden="true">#</a> 8. 查看镜像的元数据</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker inspect 容器id\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="_9-进入当前正在运行的容器" tabindex="-1"><a class="header-anchor" href="#_9-进入当前正在运行的容器" aria-hidden="true">#</a> 9. 进入当前正在运行的容器</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span>\n<span class="token comment">#====================方式一====================</span>\n<span class="token comment">#1.命令</span>\ndocker <span class="token builtin class-name">exec</span> -it 容器id bashshell\n\n<span class="token comment">#2.测试</span>\n<span class="token comment">#进入容器</span>\ndocker <span class="token builtin class-name">exec</span> -it 0694e2e1032c bin/bash\n<span class="token comment">#进入容器之后我们想干嘛干嘛，比如使用ls命令查看东西之类</span>\n<span class="token function">ls</span>\nbin  etc   lib\t  lost+found  mnt  proc  run   srv  tmp  var\ndev  home  lib64  media       opt  root  sbin  sys  usr\n\n<span class="token comment">#====================方式二====================</span>\n<span class="token comment">#1.命令</span>\ndocker attach 容器id\n<span class="token comment">#2.测试</span>\ndocker attach 0694e2e1032c\n正在执行当前的代码<span class="token punctuation">..</span>.\n<span class="token comment">#方式一和方式二的区别</span>\n<span class="token comment">#docker exec   #进入当前容器后开启一个新的终端，可以在里面操作。（常用）</span>\n<span class="token comment">#docker attach #进入容器正在执行的终端，不会启动新的进程</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="_10-从容器内拷贝到主机" tabindex="-1"><a class="header-anchor" href="#_10-从容器内拷贝到主机" aria-hidden="true">#</a> 10 .从容器内拷贝到主机</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1.命令</span>\ndocker <span class="token function">cp</span> 容器id:容器内路径（文件名）  主机目的路径\n<span class="token comment">#2.测试</span>\ndocker <span class="token function">cp</span> 0694e2e1032c:/hello.java /home \n<span class="token comment">#将容器内部的/hello.java移动到主机的/home目录下，即使容器关闭了，也可以拷贝出来</span>\n\n<span class="token comment">#拷贝是一个手动过程，未来我们使用-v卷的技术，可以实现自动同步</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_11-其他" tabindex="-1"><a class="header-anchor" href="#_11-其他" aria-hidden="true">#</a> 11. 其他</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#elasticsearch非常占内存，我们可以修改配置文件，进行限制内存使用#修改配置文件 -e 环境配置修改</span>\n<span class="token comment"># 在我们之前的启动命令中加入：-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;，限定内存在64mb-512mb之间</span>\ndocker run -d --name elasticsearch2 -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 -e <span class="token string">&quot;discovery.type=single-node&quot;</span> -e <span class="token assign-left variable">ES_JAVA_OPTS</span><span class="token operator">=</span><span class="token string">&quot;-Xms64m -Xmx512m&quot;</span> elasticsearch:7.6.2\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="容器数据卷" tabindex="-1"><a class="header-anchor" href="#容器数据卷" aria-hidden="true">#</a> 容器数据卷</h2><p><strong>容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p><h3 id="_1-v-挂载" tabindex="-1"><a class="header-anchor" href="#_1-v-挂载" aria-hidden="true">#</a> 1. -v 挂载</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1. 语法：主要是这个-v</span>\ndocker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口\n\n<span class="token comment">#2. run一个centos容器，并使用目录挂载</span>\n<span class="token comment"># /home/ceshi：主机home目录下的ceshi文件夹  映射：centos容器中的/home</span>\n<span class="token comment"># 将容器里边的home目录挂载到linux的home下边的ceshi目录</span>\ndocker run -it -v /home/ceshi:/home centos /bin/bash\n\n<span class="token comment">#3.  docker inspect 容器id 查看是否挂载成功</span>\n<span class="token punctuation">[</span>root@iZ2vc28obhvfham8wewhh0Z /<span class="token punctuation">]</span><span class="token comment"># docker inspect 54db68df3d7f</span>\n<span class="token comment">#具体看下图的Mounts部分，以后两个地址的内的数据可以相互同步的</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_2-mysql数据持久化" tabindex="-1"><a class="header-anchor" href="#_2-mysql数据持久化" aria-hidden="true">#</a> 2. mysql数据持久化</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1. 获取mysql镜像</span>\n<span class="token punctuation">[</span>root@iZ2vc28obhvfham8wewhh0Z ~<span class="token punctuation">]</span><span class="token comment"># docker pull mysql:5.7</span>\n\n<span class="token comment">#2. 运行容器的时候需要做数据挂载，此处我们挂载了配置文件以及数据目录（有两个哦），同时咱们也配置了mysql的密码</span>\n-d 后台运行\n-p 端口映射\n-v 卷挂载\n-e 环境配置\n-- name 容器名字\n<span class="token punctuation">[</span>root@iZ2vc28obhvfham8wewhh0Z ~<span class="token punctuation">]</span><span class="token comment"># docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span>\n\n<span class="token comment">#3. 启动成功之后，我们可以在本地去连接上服务器的mysql，如下图所示</span>\n<span class="token comment">#咱们走的是3310端口，3310端口映射了容器的3306端口，所以说我们本质还是访问到的容器</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="_3-具名匿名挂载" tabindex="-1"><a class="header-anchor" href="#_3-具名匿名挂载" aria-hidden="true">#</a> 3. 具名匿名挂载</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1. 匿名挂载</span>\n-v 容器内路径<span class="token operator">!</span>，这里我们没有写主机的路径，那么它就会自动的生成一个目录\n<span class="token comment">#1-1. 使用命令匿名挂载</span>\ndocker run -d -P --name nginx01 -v /etc/nginx nginx\n\n<span class="token comment">#1-1. 查看所有volume（卷）的情况  </span>\n<span class="token punctuation">[</span>root@iZ2vc28obhvfham8wewhh0Z data<span class="token punctuation">]</span><span class="token comment"># docker volume ls</span>\nDRIVER    VOLUME NAME（卷名字，这个一串乱码其实是真实存在的目录）\n<span class="token builtin class-name">local</span>     dd3decdb4e2533d16d216ba19d8797c2ad95b4a2a1b6a90f87eb98bbed3b3758\n<span class="token comment"># 注：这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路径！</span>\n\n<span class="token comment">#2. 具名挂载</span>\n<span class="token comment">#2-1. 使用命令具名挂载</span>\ndocker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx\n<span class="token comment"># 注1:juming-nginx:/etc/nginx，给/etc/nginx命名为juming-nginx，并没有写主机地址哈</span>\n<span class="token comment"># 注2:说白了就是 -v 卷名:容器内路径</span>\n\n<span class="token comment">#2-2. 查看一下这个卷</span>\n<span class="token punctuation">[</span>root@iZ2vc28obhvfham8wewhh0Z data<span class="token punctuation">]</span><span class="token comment"># docker volume inspect juming-nginx</span>\n<span class="token punctuation">[</span>\n    <span class="token punctuation">{</span>\n        <span class="token string">&quot;CreatedAt&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;2021-06-25T20:18:22+08:00&quot;</span>,\n        <span class="token string">&quot;Driver&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;local&quot;</span>,\n        <span class="token string">&quot;Labels&quot;</span><span class="token builtin class-name">:</span> null,\n        <span class="token comment">#注意看这儿：下方就是我们挂载到主机的具体路径了</span>\n        <span class="token string">&quot;Mountpoint&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;/var/lib/docker/volumes/juming-nginx/_data&quot;</span>,\n        <span class="token string">&quot;Name&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;juming-nginx&quot;</span>,\n        <span class="token string">&quot;Options&quot;</span><span class="token builtin class-name">:</span> null,\n        <span class="token string">&quot;Scope&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;local&quot;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p><strong>总结</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 三种挂载： 匿名挂载、具名挂载、指定路径挂载</span>\n-v 容器内路径\t\t\t      <span class="token comment">#匿名挂载</span>\n-v 卷名：容器内路径\t\t    <span class="token comment">#具名挂载</span>\n-v /宿主机路径：容器内路径 <span class="token comment">#指定路径挂载 docker volume ls 是查看不到的</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>扩展</strong></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 通过 -v 容器内路径： ro rw 改变读写权限</span>\nro <span class="token comment">#readonly 只读</span>\nrw <span class="token comment">#readwrite 可读可写</span>\n$ docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx\n$ docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx\n\n<span class="token comment"># ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_4-数据卷容器" tabindex="-1"><a class="header-anchor" href="#_4-数据卷容器" aria-hidden="true">#</a> 4. 数据卷容器</h3><ul><li>父容器：A去挂载B，那么B就是A的父容器</li><li>数据卷容器：被挂载的容器</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run -it --name docker02 --volumes-from docker01 centos\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p><p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile" aria-hidden="true">#</a> Dockerfile</h2><h3 id="dockerfile指令" tabindex="-1"><a class="header-anchor" href="#dockerfile指令" aria-hidden="true">#</a> Dockerfile指令</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>FROM\t\t\t\t <span class="token comment"># from:基础镜像，一切从这里开始构建</span>\nMAINTAINER  <span class="token comment"># maintainer:镜像是谁写的， 姓名+邮箱</span>\nRUN\t\t\t\t\t<span class="token comment"># run:镜像构建的时候需要运行的命令</span>\nADD\t\t\t\t\t<span class="token comment"># add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录</span>\nWORKDIR\t\t\t\t<span class="token comment"># workdir:镜像的工作目录</span>\nVOLUME\t\t\t\t<span class="token comment"># volume:挂载的目录位置</span>\nEXPOSE\t\t\t\t<span class="token comment"># expose:暴露端口配置</span>\nCMD\t\t\t\t\t<span class="token comment"># cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span>\nENTRYPOINT\t\t\t<span class="token comment"># entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令</span>\nONBUILD\t\t\t\t<span class="token comment"># onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，是触发指令</span>\nCOPY\t\t\t\t<span class="token comment"># copy:类似ADD，将我们文件拷贝到镜像中</span>\nENV\t\t\t\t\t<span class="token comment"># env:构建的时候设置环境变量！</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>FROM centos\nMAINTAINER tom<span class="token operator">&lt;</span>a@qq.com<span class="token operator">&gt;</span>\n\nENV MYPATH /usr/local\nWORKDIR <span class="token variable">$MYPATH</span>\n\nRUN yum -y <span class="token function">install</span> <span class="token function">vim</span>\nRUN yum -y <span class="token function">install</span> net-tools\n\nEXPOSE <span class="token number">80</span>\n\nCMD <span class="token builtin class-name">echo</span> <span class="token variable">$MYPATH</span>\nCMD <span class="token builtin class-name">echo</span> <span class="token string">&quot;---end---&quot;</span>\nCMD /bin/bash\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker build -f dockerfile-centos -t mycentos:0.1 <span class="token builtin class-name">.</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="cmd与entrypoint" tabindex="-1"><a class="header-anchor" href="#cmd与entrypoint" aria-hidden="true">#</a> CMD与ENTRYPOINT</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>CMD\t\t\t\t\t    <span class="token comment"># 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span>\nENTRYPOINT\t\t\t<span class="token comment"># 指定这个容器启动的时候要运行的命令，可以追加命令</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="docker网络" tabindex="-1"><a class="header-anchor" href="#docker网络" aria-hidden="true">#</a> Docker网络</h2><h3 id="_1-原理" tabindex="-1"><a class="header-anchor" href="#_1-原理" aria-hidden="true">#</a> 1. 原理</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#我们发现这个容器带来网卡，都是一对对的</span>\n<span class="token comment"># veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协议，一端彼此相连</span>\n<span class="token comment"># 正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的</span>\n<span class="token comment"># OpenStac,Docker容器之间的连接，OVS的连接，都是使用evth-pair技术</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p><em>情况一：路由器可以直接去访问容器</em></p></blockquote><p><img src="https://raw.githubusercontent.com/sunven/PicBed/master/20210704190642.png" alt="img"></p><blockquote><p><em>情况二：容器之间的访问，比如Tomcat01去访问Tomcat02，路由器就是作为一个中间商</em></p></blockquote><p><img src="https://raw.githubusercontent.com/sunven/PicBed/master/20210704190804.png" alt="img"></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#Tomcat01和Tomcat02是共用的一个路由器，docker0</span>\n<span class="token comment">#所有的容器不指定网络的情况下，都是docker0路由的，docker会给我们的容器分配一个默认的可用ip</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Docker使用的是Linux的桥接，宿主机是一个Docker容器的网桥 docker0</p><p><img src="https://raw.githubusercontent.com/sunven/PicBed/master/20210704190858.png" alt="img"></p><h3 id="_2-link" tabindex="-1"><a class="header-anchor" href="#_2-link" aria-hidden="true">#</a> 2. --link</h3><p>本质就是在hosts配置中添加映射，现在使用Docker已经不建议使用–-link了！</p><h3 id="_3-自定义网络" tabindex="-1"><a class="header-anchor" href="#_3-自定义网络" aria-hidden="true">#</a> 3. 自定义网络</h3><p><strong>网络模式：</strong></p><ul><li><strong>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</strong></li><li>none ：不配置网络，一般不用</li><li>host ：和宿主机共享网络</li><li>container ：容器网络连通（用得少！局限很大）</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 我们直接启动的命令 --net bridge,而这个就是我们的docker0</span>\n<span class="token comment"># bridge就是docker0</span>\n<span class="token comment">#&quot;--net bridge&quot;就是默认参数</span>\ndocker run -d -P --name tomcat01 tomcat\ndocker run -d -P --name tomcat01 --net bridge tomcat\n<span class="token comment">#------------------------------------------------------</span>\n<span class="token comment">#------------------------------------------------------</span>\n\n<span class="token comment">#自定义网络：</span>\n\n<span class="token comment">#1. 清理环境，删除之前的容器</span>\ndocker <span class="token function">rm</span> -f  <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span>\n\n<span class="token comment">#2. 创建一个子网为“192.168.0.0/16”，网关（路由）为“192.168.0.1”，网络名字为“mynet”的网络</span>\ndocker network create --driver bridge --subnet <span class="token number">192.168</span>.0.0/16 --gateway <span class="token number">192.168</span>.0.1 mynet\n\n<span class="token comment">#3. 查看创建的网络</span>\ndocker network <span class="token function">ls</span>\n\n<span class="token comment">#4. 创建两个个tomcat使用我们自定义的网络</span>\ndocker run -d -P --name tomcat-net-01 --net mynet tomcat\ndocker run -d -P --name tomcat-net-02 --net mynet tomcat\n\n<span class="token comment">#5. 然后查看我们自定义的网络，如下图所示</span>\ndocker network inspect 56505443b59d\n\n<span class="token comment">#6. 我们再来ping容器</span>\ndocker <span class="token builtin class-name">exec</span> -it tomcat-net-01 <span class="token function">ping</span> tomcat-net-02\ndocker <span class="token builtin class-name">exec</span> -it tomcat-net-01 <span class="token function">ping</span> <span class="token number">192.168</span>.0.3\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><h3 id="_4-网络联通" tabindex="-1"><a class="header-anchor" href="#_4-网络联通" aria-hidden="true">#</a> 4. 网络联通</h3><p><img src="https://raw.githubusercontent.com/sunven/PicBed/master/20210704191318.png" alt="img"></p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#语法：docker network connect [OPTIONS] NETWORK CONTAINER</span>\n<span class="token comment">#1. 之前删除的tomcat01和tomcat02创建好</span>\ndocker run -d -P --name tomcat01 tomcat\ndocker run -d -P --name tomcat02 tomcat\n\n<span class="token comment">#2. 打通tomcat01和mynet</span>\ndocker network connect mynet tomcat01\n\n<span class="token comment">#3. 查看网络配置，如下图所示：</span>\ndocker network inspect mynet\n<span class="token comment"># 要将tomcat01 连通 tomcat—net-01 ，连通就是将 tomcat01加到 mynet网络</span>\n<span class="token comment"># 一个容器两个ip（tomcat01）</span>\n\n<span class="token comment">#4. 现在我们再ping一下</span>\n<span class="token punctuation">[</span>root@iZ2vc28obhvfham8wewhh0Z ~<span class="token punctuation">]</span><span class="token comment"># docker exec -it tomcat01 ping tomcat-net-02</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="_5-测试" tabindex="-1"><a class="header-anchor" href="#_5-测试" aria-hidden="true">#</a> 5.测试</h3><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment">#1. 先移除之前的容器</span>\ndocker <span class="token function">rm</span> -f <span class="token variable"><span class="token variable">$(</span>docker <span class="token function">ps</span> -aq<span class="token variable">)</span></span>\n\n<span class="token comment">#2. 创建redis的网卡</span>\ndocker network create redis --subnet <span class="token number">172.38</span>.0.0/16\n\n<span class="token comment">#3. 通过脚本去写配置文件</span>\n<span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span><span class="token punctuation">\\</span>\n<span class="token keyword">do</span> <span class="token punctuation">\\</span>\n<span class="token function">mkdir</span> -p /mydata/redis/node-<span class="token variable">${port}</span>/conf\n<span class="token function">touch</span> /mydata/redis/node-<span class="token variable">${port}</span>/conf/redis.conf\n<span class="token function">cat</span> <span class="token operator">&lt;&lt;</span> <span class="token string">EOF<span class="token bash punctuation"> <span class="token operator">&gt;&gt;</span> /mydata/redis/node-<span class="token variable">${port}</span>/conf/redis.conf</span>\nport 6379\nbind 0.0.0.0\ncluster-enabled yes\ncluster-config-file nodes.conf\ncluster-node-timeout 5000\ncluster-announce-ip 172.38.0.1<span class="token variable">${port}</span>\ncluster-announce-port 6379\ncluster-announce-bus-port 16379\nappendonly yes\nEOF</span>\n<span class="token keyword">done</span>\n\n<span class="token comment">#4. 通过脚本创建六个redis文件</span>\n<span class="token keyword">for</span> <span class="token for-or-select variable">port</span> <span class="token keyword">in</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">seq</span> <span class="token number">1</span> <span class="token number">6</span><span class="token variable">)</span></span><span class="token punctuation">;</span><span class="token punctuation">\\</span>\ndocker run -p <span class="token number">637</span><span class="token variable">${port}</span>:6379 -p <span class="token number">1637</span><span class="token variable">${port}</span>:16379 --name redis-<span class="token variable">${port}</span> <span class="token punctuation">\\</span>\n-v /mydata/redis/node-<span class="token variable">${port}</span>/data:/data <span class="token punctuation">\\</span>\n-v /mydata/redis/node-<span class="token variable">${port}</span>/conf/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\\</span>\n-d --net redis --ip <span class="token number">172.38</span>.0.1<span class="token variable">${port}</span> redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf<span class="token punctuation">;</span> <span class="token punctuation">\\</span>\n<span class="token comment">#5. 然后依次运行</span>\ndocker <span class="token builtin class-name">exec</span> -it redis-1 /bin/sh \ndocker <span class="token builtin class-name">exec</span> -it redis-2 /bin/sh \ndocker <span class="token builtin class-name">exec</span> -it redis-3 /bin/sh \ndocker <span class="token builtin class-name">exec</span> -it redis-4 /bin/sh \ndocker <span class="token builtin class-name">exec</span> -it redis-5 /bin/sh \ndocker <span class="token builtin class-name">exec</span> -it redis-6 /bin/sh \n\n<span class="token comment">#6. 创建集群</span>\nredis-cli --cluster create <span class="token number">172.38</span>.0.11:6379 <span class="token number">172.38</span>.0.12:6379 <span class="token number">172.38</span>.0.13:6379 <span class="token number">172.38</span>.0.14:6379 <span class="token number">172.38</span>.0.15:6379 <span class="token number">172.38</span>.0.16:6379  --cluster-replicas <span class="token number">1</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><h2 id="docker-compose" tabindex="-1"><a class="header-anchor" href="#docker-compose" aria-hidden="true">#</a> Docker Compose</h2><p>定义运行多个容器</p><p>地址：https://docs.docker.com/compose/gettingstarted/</p><p>https://docs.docker.com/compose/wordpress/</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker-compose down         <span class="token comment"># 关闭容器</span>\ndocker-compose up --build   <span class="token comment"># 重新构建</span>\ndocker-compose up -d\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="docker-swarm" tabindex="-1"><a class="header-anchor" href="#docker-swarm" aria-hidden="true">#</a> Docker Swarm</h2><p>4台机器，xshell同步操作</p><p><img src="https://docs.docker.com/engine/swarm/images/swarm-diagram.png" alt="img"></p><h3 id="manager-nodes" tabindex="-1"><a class="header-anchor" href="#manager-nodes" aria-hidden="true">#</a> Manager nodes</h3>',98),p=(0,e.Uk)("使用"),c={href:"https://raft.github.io/raft.pdf",target:"_blank",rel:"noopener noreferrer"},r=(0,e.Uk)("Raft"),t=(0,e.Uk)("实现，管理者保持整个群和所有运行在它的服务的一致内部状态"),o=(0,e.uE)('<ul><li>管理集群状态</li><li>调度</li></ul><p>可故障的管理节点数:(N-1)/2</p><p>3个最多可以有一个故障</p><p>5个最多可以有两个故障</p><p>一个几圈最多简易有7个管理节点</p><p>增加更多的管理者并不意味着可扩展性或更高的性能。一般来说，情况正好相反</p><h3 id="worker-nodes" tabindex="-1"><a class="header-anchor" href="#worker-nodes" aria-hidden="true">#</a> Worker nodes</h3><ul><li>执行容器</li></ul><h3 id="命令" tabindex="-1"><a class="header-anchor" href="#命令" aria-hidden="true">#</a> 命令</h3><p>初始化</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker swarm init --help\n \n<span class="token function">ip</span> addr <span class="token comment"># 获取自己的ip（用内网的不要流量）</span>\n \ndocker swarm init --advertise-addr <span class="token number">172.16</span>.250.97\nSwarm initialized: current node <span class="token punctuation">(</span>otdyxbk2ffbogdqq1kigysj1d<span class="token punctuation">)</span> is now a manager.\nTo <span class="token function">add</span> a worker to this swarm, run the following command:\n    docker swarm <span class="token function">join</span> --token SWMTKN-1-3vovnwb5pkkno2i3u2a42yrxc1dk51zxvto5hrm4asgn37syfn-0xkrprkuyyhrx7cidg381pdir <span class="token number">172.16</span>.250.97:2377\nTo <span class="token function">add</span> a manager to this swarm, run <span class="token string">&#39;docker swarm join-token manager&#39;</span> and follow the instructions.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 获取令牌</span>\ndocker swarm join-token manager\ndocker swarm join-token worker\n\n<span class="token comment"># 加入swarm</span>\ndocker swarm <span class="token function">join</span> --token SWMTKN-1-3vovnwb5pkkno2i3u2a42yrxc1dk51zxvto5hrm4asgn37syfn-0xkrprkuyyhrx7cidg381pdir <span class="token number">172.16</span>.250.97:2377\n\n<span class="token comment"># 离开swarm</span>\ndocker swarm leave\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run     <span class="token comment"># 容器启动！ 不具有扩缩容器</span>\ndocker <span class="token function">service</span> <span class="token comment"># 服务！ 具有扩缩容器，滚动更新！</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 查看服务列表</span>\ndocker <span class="token function">service</span> <span class="token function">ls</span>\n\n<span class="token comment"># 查看服务信息</span>\ndocker <span class="token function">service</span> <span class="token function">ps</span> servicename\n\n<span class="token comment"># 扩缩容</span>\ndocker <span class="token function">service</span> update --replicas <span class="token number">3</span> my-nginx\ndocker <span class="token function">service</span> scale my-nginx<span class="token operator">=</span><span class="token number">5</span>\n\n<span class="token comment"># 移除</span>\ndocker <span class="token function">service</span> <span class="token function">rm</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="service如何工作" tabindex="-1"><a class="header-anchor" href="#service如何工作" aria-hidden="true">#</a> service如何工作</h3><p><img src="https://docs.docker.com/engine/swarm/images/services-diagram.png" alt="services diagram"></p><h3 id="任务和调度" tabindex="-1"><a class="header-anchor" href="#任务和调度" aria-hidden="true">#</a> 任务和调度</h3><p><img src="https://docs.docker.com/engine/swarm/images/service-lifecycle.png" alt="services flow"></p><h3 id="副本和服务" tabindex="-1"><a class="header-anchor" href="#副本和服务" aria-hidden="true">#</a> 副本和服务</h3><p><img src="https://docs.docker.com/engine/swarm/images/replicated-vs-global.png" alt="global vs replicated services"></p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> reference</h2>',21),i={href:"https://blog.csdn.net/GTX_WU/article/details/118370049",target:"_blank",rel:"noopener noreferrer"},m=(0,e.Uk)("狂神Docker学习笔记_Lemonyuki的博客-CSDN博客"),b={href:"https://u19900101.github.io/2021-04-16-Docker%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_21h2d/",target:"_blank",rel:"noopener noreferrer"},u=(0,e.Uk)("Docker入门学习笔记(21h/2d 4.14-16) (u19900101.github.io)"),d={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[l,(0,e._)("p",null,[p,(0,e._)("a",c,[r,(0,e.Wm)(a)]),t]),o,(0,e._)("p",null,[(0,e._)("a",i,[m,(0,e.Wm)(a)])]),(0,e._)("p",null,[(0,e._)("a",b,[u,(0,e.Wm)(a)])])],64)}}}}]);